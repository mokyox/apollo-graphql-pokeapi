/* eslint-disable */
// @ts-nocheck
// This file is automatically generated using graphql-code-generator
import { GraphQLResolveInfo } from "graphql";
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: any }> = { [K in keyof T]: T[K] };
export type RequireFields<T, K extends keyof T> = {
  [X in Exclude<keyof T, K>]?: T[X];
} &
  { [P in K]-?: NonNullable<T[P]> };

/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

export type Query = {
  __typename?: "Query";
  getPokemon?: Maybe<Pokemon>;
  getDescription?: Maybe<Description>;
};

export type QueryGetPokemonArgs = {
  id: Scalars["Int"];
};

export type QueryGetDescriptionArgs = {
  id: Scalars["Int"];
};

export type Pokemon = {
  __typename?: "Pokemon";
  id?: Maybe<Scalars["Int"]>;
  name?: Maybe<Scalars["String"]>;
  abilities?: Maybe<Array<Maybe<AbilityData>>>;
  stats?: Maybe<Array<Maybe<StatsData>>>;
  description?: Maybe<Array<Maybe<Description>>>;
};

export type Ability = {
  __typename?: "Ability";
  name?: Maybe<Scalars["String"]>;
  url?: Maybe<Scalars["String"]>;
};

export type AbilityData = {
  __typename?: "AbilityData";
  ability?: Maybe<Ability>;
  is_hidden: Scalars["Boolean"];
};

export type Stats = {
  __typename?: "Stats";
  name?: Maybe<Scalars["String"]>;
  url?: Maybe<Scalars["String"]>;
};

export type StatsData = {
  __typename?: "StatsData";
  stat?: Maybe<Stats>;
  base_stat?: Maybe<Scalars["Int"]>;
};

export type Description = {
  __typename?: "Description";
  flavor_text?: Maybe<Scalars["String"]>;
  language?: Maybe<LanguageData>;
  version?: Maybe<VersionData>;
};

export type LanguageData = {
  __typename?: "LanguageData";
  name?: Maybe<Scalars["String"]>;
  url?: Maybe<Scalars["String"]>;
};

export type VersionData = {
  __typename?: "VersionData";
  name?: Maybe<Scalars["String"]>;
  url?: Maybe<Scalars["String"]>;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> =
  | LegacyStitchingResolver<TResult, TParent, TContext, TArgs>
  | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {}
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}> = (
  obj: T,
  info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {}
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Query: ResolverTypeWrapper<{}>;
  Int: ResolverTypeWrapper<Scalars["Int"]>;
  Pokemon: ResolverTypeWrapper<Pokemon>;
  String: ResolverTypeWrapper<Scalars["String"]>;
  Ability: ResolverTypeWrapper<Ability>;
  AbilityData: ResolverTypeWrapper<AbilityData>;
  Boolean: ResolverTypeWrapper<Scalars["Boolean"]>;
  Stats: ResolverTypeWrapper<Stats>;
  StatsData: ResolverTypeWrapper<StatsData>;
  Description: ResolverTypeWrapper<Description>;
  LanguageData: ResolverTypeWrapper<LanguageData>;
  VersionData: ResolverTypeWrapper<VersionData>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Query: {};
  Int: Scalars["Int"];
  Pokemon: Pokemon;
  String: Scalars["String"];
  Ability: Ability;
  AbilityData: AbilityData;
  Boolean: Scalars["Boolean"];
  Stats: Stats;
  StatsData: StatsData;
  Description: Description;
  LanguageData: LanguageData;
  VersionData: VersionData;
}>;

export type QueryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Query"] = ResolversParentTypes["Query"]
> = ResolversObject<{
  getPokemon?: Resolver<
    Maybe<ResolversTypes["Pokemon"]>,
    ParentType,
    ContextType,
    RequireFields<QueryGetPokemonArgs, "id">
  >;
  getDescription?: Resolver<
    Maybe<ResolversTypes["Description"]>,
    ParentType,
    ContextType,
    RequireFields<QueryGetDescriptionArgs, "id">
  >;
}>;

export type PokemonResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Pokemon"] = ResolversParentTypes["Pokemon"]
> = ResolversObject<{
  id?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  abilities?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["AbilityData"]>>>,
    ParentType,
    ContextType
  >;
  stats?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["StatsData"]>>>,
    ParentType,
    ContextType
  >;
  description?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Description"]>>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
}>;

export type AbilityResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Ability"] = ResolversParentTypes["Ability"]
> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
}>;

export type AbilityDataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["AbilityData"] = ResolversParentTypes["AbilityData"]
> = ResolversObject<{
  ability?: Resolver<Maybe<ResolversTypes["Ability"]>, ParentType, ContextType>;
  is_hidden?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
}>;

export type StatsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Stats"] = ResolversParentTypes["Stats"]
> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
}>;

export type StatsDataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["StatsData"] = ResolversParentTypes["StatsData"]
> = ResolversObject<{
  stat?: Resolver<Maybe<ResolversTypes["Stats"]>, ParentType, ContextType>;
  base_stat?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
}>;

export type DescriptionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Description"] = ResolversParentTypes["Description"]
> = ResolversObject<{
  flavor_text?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  language?: Resolver<
    Maybe<ResolversTypes["LanguageData"]>,
    ParentType,
    ContextType
  >;
  version?: Resolver<
    Maybe<ResolversTypes["VersionData"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
}>;

export type LanguageDataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LanguageData"] = ResolversParentTypes["LanguageData"]
> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
}>;

export type VersionDataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["VersionData"] = ResolversParentTypes["VersionData"]
> = ResolversObject<{
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  Query?: QueryResolvers<ContextType>;
  Pokemon?: PokemonResolvers<ContextType>;
  Ability?: AbilityResolvers<ContextType>;
  AbilityData?: AbilityDataResolvers<ContextType>;
  Stats?: StatsResolvers<ContextType>;
  StatsData?: StatsDataResolvers<ContextType>;
  Description?: DescriptionResolvers<ContextType>;
  LanguageData?: LanguageDataResolvers<ContextType>;
  VersionData?: VersionDataResolvers<ContextType>;
}>;

/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = any> = Resolvers<ContextType>;
